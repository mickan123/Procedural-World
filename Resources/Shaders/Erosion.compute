#pragma kernel HydraulicErosion

#define LDIR(col) (col.r)
#define RDIR(col) (col.g)
#define TDIR(col) (col.b)
#define BDIR(col) (col.a)

#define TERRAIN_HEIGHT(col) (col.r)
#define WATER_HEIGHT(col) (col.g)
#define SEDIMENT(col) (col.b)
#define PLACEHOLDER(col) (col.a)
#define FULL_HEIGHT(col) (TERRAIN_HEIGHT(col) + WATER_HEIGHT(col))

#define SAMPLE_WITH_OFFSET(tex, x, y) (tex[id.x])
#define CURRENT_SAMPLE(tex) (tex[id.x])
#define LEFT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, -1, 0))
#define RIGHT_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 1, 0))
#define TOP_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, 1))
#define BOTTOM_SAMPLE(tex) (SAMPLE_WITH_OFFSET(tex, 0, -1))

#define SUM_COMPS(v) ((v.r + v.g + v.b + v.a))

#define IS_LEFT_BORDER (id.x % mapSize == 0)
#define IS_RIGHT_BORDER (id.x % mapSize == mapSize - 1)
#define IS_TOP_BORDER (uint(id.x) / uint(mapSize) == 0)
#define IS_BOTTOM_BORDER (uint(id.x) / uint(mapSize) == uint(mapSize) - 1)


// Heightmap, r = height, g = water height, b = sediment, r = placeholder
RWStructuredBuffer<float4> HeightMap;

// Water flux field, r = left, g = right, b = top, a = bottom
RWStructuredBuffer<float4> FluxMap;

// Velocity field, r = x, g = y
RWStructuredBuffer<float2> VelocityMap;

StructuredBuffer<int> RainfallIndices;

uint mapSize;
float timestep;
float rainfallAmount;
float evaporateSpeed;
float gravity;
float sedimentCapacityFactor;
float sedimentDisolveFactor;
float sedimentDepositFactor;

float stepSize;
float pipeArea;

float4 SampleBilinear(RWStructuredBuffer<float4> buff, float2 uv)
{
	float2 uva = floor(uv);
	float2 uvb = ceil(uv);

	uint2 id00 = (uint2)uva;  // 0 0
	uint2 id10 = uint2(uvb.x, uva.y); // 1 0
	uint2 id01 = uint2(uva.x, uvb.y); // 0 1	
	uint2 id11 = (uint2)uvb; // 1 1

	float2 d = uv - uva;

	return
		buff[id00.x + id00.y * mapSize] * (1 - d.x) * (1 - d.y) +
		buff[id10.x + id10.y * mapSize] * d.x * (1 - d.y) +
		buff[id01.x + id01.y * mapSize] * (1 - d.x) * d.y +
		buff[id11.x + id11.y * mapSize] * d.x * d.y;
}


void WaterIncrease(uint3 id : SV_DispatchThreadID, int iteration)
{
    if (RainfallIndices[iteration] == id.x)
    {
        float4 state = CURRENT_SAMPLE(HeightMap);
        WATER_HEIGHT(state) += rainfallAmount * timestep;
    }
}

void FluxComputation(uint3 id : SV_DispatchThreadID)
{
    float4 state = CURRENT_SAMPLE(HeightMap);
    float4 stateLeft = IS_LEFT_BORDER ? state : HeightMap[id.x - 1];
	float4 stateRight = IS_RIGHT_BORDER ? state : HeightMap[id.x + 1];
	float4 stateTop = IS_TOP_BORDER ? state : HeightMap[id.x - mapSize];
	float4 stateBottom = IS_BOTTOM_BORDER ? state : HeightMap[id.x + mapSize];

    float terrainHeight = TERRAIN_HEIGHT(state);
	float waterHeight = WATER_HEIGHT(state);

    float4 outputFlux = CURRENT_SAMPLE(FluxMap);

    float4 deltaHeight = FULL_HEIGHT(state) - float4(
        FULL_HEIGHT(stateLeft),
        FULL_HEIGHT(stateRight),
        FULL_HEIGHT(stateTop),
        FULL_HEIGHT(stateBottom)
    );

    outputFlux = max(0, outputFlux + timestep * gravity * deltaHeight * pipeArea / stepSize);
    
    // Rescale flux to not exceed total amount of water in a cell
    float sumOutputFlux = SUM_COMPS(outputFlux);
    if (sumOutputFlux != 0)
    {
        outputFlux *= min(1, waterHeight * stepSize * stepSize / (SUM_COMPS(outputFlux) * timestep));
    }

    // Write sample
    CURRENT_SAMPLE(FluxMap) = max(0, outputFlux);
}

void VelocityComputation(uint3 id : SV_DispatchThreadID)
{
    float4 state = CURRENT_SAMPLE(HeightMap);

	float4 outputFlux = CURRENT_SAMPLE(FluxMap);
	float4 inputFlux = float4(
		IS_LEFT_BORDER ? 0 : RDIR(HeightMap[id.x - 1]),
		IS_RIGHT_BORDER ? 0 : LDIR(HeightMap[id.x + 1]),
		IS_TOP_BORDER ? 0 : BDIR(HeightMap[id.x - mapSize]),
		IS_BOTTOM_BORDER ? 0 : TDIR(HeightMap[id.x + mapSize])
    );
	float waterHeightBefore = WATER_HEIGHT(state);

	// Water surface and velocity field update
	// volume is changing by amount on incoming fluid volume minus outgoing
	float volumeDelta = timestep * (SUM_COMPS(inputFlux) - SUM_COMPS(outputFlux));	

	// Then, we update the water height in the current (x, y) cell:
	WATER_HEIGHT(state) += max(volumeDelta / (stepSize * stepSize), -WATER_HEIGHT(state));	

	// Write new state to the HeightMap
	CURRENT_SAMPLE(HeightMap) = state;

    float averageWater = 0.5 * (waterHeightBefore + WATER_HEIGHT(state));
    float velocityScale = (averageWater == 0) ? 1 : stepSize * averageWater;

	// Compute new velocity from flux to the VelocityMap
    CURRENT_SAMPLE(VelocityMap) = float2(
        0.5 * (LDIR(inputFlux) - LDIR(outputFlux) + RDIR(outputFlux) - RDIR(inputFlux)),
        0.5 * (BDIR(inputFlux) - BDIR(outputFlux) + TDIR(outputFlux) - TDIR(inputFlux))
    ) / velocityScale;
}

void ErosionDeposition(uint3 id : SV_DispatchThreadID)
{
    // Sample the heighmap
	float4 state = CURRENT_SAMPLE(HeightMap);
	float4 stateLeft = IS_LEFT_BORDER ? state : HeightMap[id.x - 1];
	float4 stateRight = IS_RIGHT_BORDER ? state : HeightMap[id.x + 1];
	float4 stateTop = IS_TOP_BORDER ? state : HeightMap[id.x - mapSize];
	float4 stateBottom = IS_BOTTOM_BORDER ? state : HeightMap[id.x + mapSize];
	float2 velocity = CURRENT_SAMPLE(VelocityMap);

	// Tilt angle computation
	float3 dhdx = float3(2 * stepSize, TERRAIN_HEIGHT(stateRight) - TERRAIN_HEIGHT(stateLeft), 0);
	float3 dhdy = float3(0, TERRAIN_HEIGHT(stateTop) - TERRAIN_HEIGHT(stateBottom), 2 * stepSize);
	float3 normal = cross(dhdx, dhdy);

	float sinTiltAngle = abs(normal.y) / length(normal);

    float maxErosionDepth = 1;
    float lmax = saturate(1 - max(0, maxErosionDepth - WATER_HEIGHT(state)) / maxErosionDepth);
    float sedimentCapacity = sedimentCapacityFactor * length(velocity) * min(sinTiltAngle, 0.05) * lmax;

    // Take sediment from soil if we haven't filled up capacity
    if (SEDIMENT(state) < sedimentCapacity)
    {
        float deltaSediment = timestep * sedimentDisolveFactor * (sedimentCapacity - SEDIMENT(state));
        TERRAIN_HEIGHT(state) -= deltaSediment;
		SEDIMENT(state) += deltaSediment;
		// WATER_HEIGHT(state) += deltaSediment;
    }
    else // Deposit sediment if we are over capacity
    {
        float deltaSediment = timestep * sedimentDepositFactor * (SEDIMENT(state) - sedimentCapacity);
        TERRAIN_HEIGHT(state) += deltaSediment;
		SEDIMENT(state) -= deltaSediment;
		// WATER_HEIGHT(state) -= deltaSediment;
    }

    // Water evaporation.
	WATER_HEIGHT(state) *= (1 - evaporateSpeed) * timestep;

    // Write sample
    CURRENT_SAMPLE(HeightMap) = state;
}

void SedimentTransportation(uint3 id : SV_DispatchThreadID)
{
    float4 state = CURRENT_SAMPLE(HeightMap);
    float2 velocity = CURRENT_SAMPLE(VelocityMap);

    float2 pos = float2(
        int(id.x % mapSize),
        int(id.x / mapSize)
    );

    SEDIMENT(state) = SEDIMENT(SampleBilinear(HeightMap, pos + velocity * timestep));

    CURRENT_SAMPLE(HeightMap) = state;
}



[numthreads(1024,1,1)]
void HydraulicErosion(uint3 id : SV_DispatchThreadID)
{
    // WaterIncrease(id, iteration);
    FluxComputation(id);
    VelocityComputation(id);
    ErosionDeposition(id);
    SedimentTransportation(id);
}